<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../hax-body/hax-store.html">
<link rel="import" href="../hax-body/hax-body.html">
<link rel="import" href="../hax-body/hax-autoloader.html">
<link rel="import" href="../hax-body/hax-manager.html">
<link rel="import" href="../hax-body/hax-panel.html">
<link rel="import" href="../hax-body/hax-app-picker.html">
<link rel="import" href="../hax-body/hax-export-dialog.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<link rel="import" href="cms-token.html">
<link rel="import" href="cms-block.html">
<link rel="import" href="cms-views.html">
<link rel="import" href="cms-entity.html">
<!--
`cms-hax`
A LRN polymer app

@demo ../../demo/index.html

@microcopy - the mental model for this app
 -
 -

-->
<dom-module id="cms-hax">
  <template>
    <style>
      :host {
        display: block;
        font-size: 1em;
        box-sizing: content-box;
      }
    </style>
    <div id="autoloaderslot" hidden><slot name="autoloader"></slot></div>
    <div id="bodyslot" hidden><slot></slot></div>
    <hax-store hidden app-store="[[appStoreConnection]]" valid-tag-list="[[allowedTags]]"></hax-store>
    <hax-autoloader id="loader" hidden></hax-autoloader>
    <hax-panel id="panel" hide-export-button="{{hideExportButton}}" align="[[align]]"></hax-panel>
    <hax-body id="body" context-offset-left="[[bodyOffsetLeft]]"></hax-body>
    <hax-manager></hax-manager>
    <hax-app-picker></hax-app-picker>
    <hax-export-dialog></hax-export-dialog>
    <iron-ajax
      id="pageupdateajax"
      url="[[endPoint]]"
      method="[[method]]"
      body="[[updatePageData]]"
      content-type="application/json"
      handle-as="json"
      on-response="_handleUpdateResponse"></iron-ajax>
    <cms-token></cms-token>
    <cms-views></cms-views>
    <cms-block></cms-block>
    <cms-entity></cms-entity>
    <paper-toast id="toast" horizontal-align="left"></paper-toast>
  </template>
  <script>
    Polymer({
      is: 'cms-hax',
      properties: {
        /**
         * Default the panel to open
         */
        openDefault: {
          type: Boolean,
          value: false,
        },
        /**
         * Hide the export button, not a common thing to show
         * in this mode but it's possible for debugging
         */
        hideExportButton: {
          type: Boolean,
          value: true,
        },
        /**
         * Direction to align the hax edit panel
         */
        align: {
          type: String,
          value: 'right',
        },
        /**
         * allowed Tags, usually as dictated by the input filtering
         * layer of the backend system that HAX is riding on.
         * While not fullproof, this at least will enforce front-end
         * filtering to match what actually is going to be allowed
         * to be saved in the first place.
         */
        allowedTags: {
          type: Array,
        },
        /**
         * Location to save content to.
         */
        endPoint: {
          type: String,
        },
        /**
         * Method to save content.
         */
        method: {
          type: String,
          value: 'PUT',
        },
        /**
         * Page data, body of text as a string.
         */
        updatePageData: {
          type: String,
        },
        /**
         * Connection object for talking to an app store.
         */
        appStoreConnection: {
          type: Object,
        },
        /**
         * Offset from the left of the body field
         */
        bodyOffsetLeft: {
          type: Number,
          value: -164,
        },
        /**
         * State of the panel
         */
        editMode: {
          type: Boolean,
          reflectToAttribute: true,
        },
        /**
         * syncBody
         */
        syncBody: {
          type: Boolean,
          value: false,
        },
        /**
         * Only available if syncBody is true; this allows data binding to the value being worked on in hax-body tag
         */
        bodyValue: {
          type: String,
          value: '',
        },
        /**
         * Flag to hide the toast.
         */
        hideMessage: {
          type: Boolean,
          value: false,
        },
      },
      /**
       * Attached to the DOM; now we can fire event to the store that
       * we exist and are the thing being edited.
       */
      attached: function() {
        this.__lock = false;
        document.body.addEventListener('hax-store-property-updated', this._haxStorePropertyUpdated.bind(this));
        document.body.addEventListener('hax-save', this._saveFired.bind(this));
        // @todo, step through slot for both areas injecting them CORRECTLY into the right area
        setTimeout( () => {
          this._slotRemap(this.$.autoloaderslot, this.$.loader);
          this._slotRemap(this.$.bodyslot, Polymer.HaxStore.instance.activeHaxBody);
          // open things by default and set state for edit mode
          if (this.openDefault) {
            Polymer.HaxStore.write('editMode', true, this);
          }
        }, 100);

        // notice ANY change to body and bubble up, only when we are attached though
        if (this.syncBody) {
          Polymer.dom(this.$.body).observeNodes(function(info) {
            if (!this.__lock) {
              this.__lock = true;
              this.fire('hax-body-content-changed', Polymer.HaxStore.instance.activeHaxBody.haxToContent());
              setTimeout( () => {
                this.__lock = false;
              }, 100);
            }
          });
        }
      },
      /**
       * Slot re-append correction. This helps translate shadow of one to another.
       */
      _slotRemap: function(from, to) {
        // add HTML to a div which makes it's DOM unpack
        let tmp = from;
        // trap for text without wrapping HTML tags
        if (tmp.firstChild == null) {
          var tmp2 = document.createElement('p');
          tmp2.innerHTML = tmp.innerHTML;
          tmp = document.createElement('div');
          tmp.innerHTML = tmp2.innerHTML;
        }
        else if (typeof tmp.firstChild.length !== typeof undefined) {
          var tmp2 = document.createElement('p');
          tmp2.innerHTML = tmp.innerHTML;
          tmp = document.createElement('div');
          tmp.innerHTML = tmp2.innerHTML;
        }
        // same as above but in reverse; now take stuf from what
        // came across and correctly add it into the slot
        while (tmp.firstChild) {
          Polymer.dom(to).appendChild(tmp.firstChild);
        }
        // clear from
        let slot = from;
        while (slot.firstChild !== null) {
          slot.removeChild(slot.firstChild);
        }
      },
      /**
       * Store updated, sync.
       */
      _haxStorePropertyUpdated: function(e) {
        if (e.detail && typeof e.detail.value !== typeof undefined && e.detail.property) {
          this.set(e.detail.property, e.detail.value);
        }
      },
      /**
       * _saveFired
       */
      _saveFired: function(e) {
        // generate sanitized content
        this.updatePageData = Polymer.HaxStore.instance.activeHaxBody.haxToContent();
        // send the request
        this.$.pageupdateajax.generateRequest();
      },
      /**
       * _handleUpdateResponse
       */
      _handleUpdateResponse: function(e) {
        if (!this.hideMessage) {
          this.$.toast.show('Saved!');
        }
      },
    });
  </script>
</dom-module>
